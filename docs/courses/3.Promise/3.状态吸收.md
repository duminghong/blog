---
layoutClass: doc-layout
title: Promise的状态吸收
date: 2025-10-08 20:50:12
---

# Promise 的状态吸收

状态吸收指的是两个 `promise` ，其中一个去吸收另一个的状态，当一个 `promise` 状态改变时，另一个 `promise` 也会跟着改变。

## 可能发生的场景 {#可能发生的场景}

状态吸收可能发生在多个场景：

```javascript
// 一个完成的 promise
const promise1 = Promise.resolve('success');
// 一个拒绝的 promise
const promiseReject = Promise.reject('error');
```

**1. 构造函数中的状态吸收**

```javascript
// 新new一个 promise2 ，resolve的是一个 promise1，这时候 promise2 会吸收 promise1 的状态
const promise2 = new Promise((resolve, reject) => {
  resolve(promise1);
});
```

**2. then 链式调用中的状态吸收**

```javascript
// then 方法返回的 promise3 会吸收 then 方法中的 promise1 状态
const promise3 = promise1.then((value) => promise1);
```

**3. async 函数中的状态吸收**

```javascript
// async 函数返回的 promise4 会吸收 async 函数中的 promise1 状态
async function test() {
  return promise1;
}
const promise4 = test();
```

**4. Promise.race 和 Promise.all 中的状态吸收**

```javascript
// promise5 会吸收最先完成的 promise 的状态
const promise5 = Promise.race([promise1, new Promise((resolve) => setTimeout(resolve, 100))]);

// promise6 会吸收所有 promise 的状态，当所有都完成时才会 fulfilled
const promise6 = Promise.all([promise1, Promise.resolve('another')]);
```

**5. Promise.resolve 和 Promise.reject 中的状态吸收**

```javascript
// 直接吸收 promise1 的状态
const promise7 = Promise.resolve(promise1);

// 吸收 promiseReject 的拒绝状态
const promise8 = Promise.reject(promiseReject);
```

**6. catch 方法中的状态吸收**

```javascript
// 返回一个新的 promise，promise9 会吸收这个 promise 的状态
const promise9 = promiseReject.catch((reason) => {
  return promise1;
});
```

**7. finally 方法中的状态吸收**

```javascript
// 返回一个新的 promise，promise10 会吸收这个 promise 的状态
const promise10 = promise1.finally(() => {
  return promiseReject;
});
```

**8. Promise 链中的状态吸收**

```javascript
// promise11 会吸收链中最后一个返回的 promise 的状态
const promise11 = promise1
  .then((value) => {
    console.log(value); // 'success'
    return Promise.resolve('chain1'); // 返回一个新的 promise
  })
  .then((value) => {
    console.log(value); // 'chain1'
    return Promise.reject('chainError'); // 返回一个拒绝的 promise
  })
  .catch((reason) => {
    console.log(reason); // 'chainError'
    return Promise.resolve('recovered'); // 返回一个新的 promise
  });
```

**9. Promise.any 和 Promise.allSettled 中的状态吸收**

```javascript
// promise12 会吸收最先 fulfilled 的 promise 的状态
const promise12 = Promise.any([promiseReject, Promise.reject('another'), promise1]);

// promise13 会吸收所有 promise 的状态，无论 fulfilled 还是 rejected
const promise13 = Promise.allSettled([promise1, promiseReject]);
```

**10. 嵌套 Promise 中的状态吸收**

```javascript
// promise14 会吸收内部 promise1 的状态
function nestedPromise() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(promise1); // 嵌套返回另一个 promise
    }, 100);
  });
}
const promise14 = nestedPromise();
```

## 状态吸收的过程 {#状态吸收的过程}

`V8引擎`的`状态吸收机制`是一个精心设计的过程，涉及`微任务队列`的精确调度。当需要吸收一个`Promise`的状态时，`V8引擎`会创建特定的`微任务`并按顺序放入`微队列`中执行，主要分为以下两个关键步骤：

### 1. 准备阶段 {#准备阶段}

在`准备阶段`，`V8引擎`会进行以下操作：

- **识别`Promise`依赖关系**：引擎会识别出哪些`Promise`对象之间存在`状态依赖关系`，即一个`Promise`的状态需要跟随另一个`Promise`的状态变化。这是通过检查`resolve`参数是否为`thenable`对象（具有`then`方法的对象）来实现的。

- **创建`PromiseResolveThenableJob`微任务**：当检测到需要吸收状态时，`V8引擎`会创建第一个`微任务` —— `PromiseResolveThenableJob`。这个任务负责处理`thenable`对象的`状态吸收逻辑`，确保状态能够正确地从`源Promise`传递到`目标Promise`。

- **建立`状态观察者关系`**：`V8引擎`会在内部建立`观察者模式`，需要吸收状态的`Promise`（例如`promise2`）注册为被观察`Promise`（例如`promise1`）的`状态观察者`。这是通过`PromiseReaction`机制实现的，每个`Promise`都有一个内部属性`[[PromiseReactions]]`，用于存储所有依赖它的`Promise`的`反应`。

- **保存`执行上下文`**：引擎会保存当前`执行上下文`，包括需要执行的`回调函数`和相关的`Promise`引用，确保在`微任务`执行时能够正确恢复执行环境。

```javascript
// 示例代码展示准备阶段
const promise1 = Promise.resolve('success');
const promise2 = new Promise((resolve, reject) => {
  // 当resolve(promise1)被调用时，V8引擎进入准备阶段
  // 1. 识别promise2依赖于promise1
  // 2. 将promise2设置为promise1的状态观察者
  // 3. 由于promise1已经是fulfilled状态，保存resolve回调
  resolve(promise1);
});
```

### 2. 吸收阶段 {#吸收阶段}

在`吸收阶段`，`V8引擎`会按特定顺序执行`微任务队列`中的任务：

- **执行`PromiseResolveThenableJob`**：第一个`微任务` `PromiseResolveThenableJob`会被执行，它会调用`源Promise`的`then`方法，并传入两个`回调函数`：一个用于处理`fulfilled`状态，另一个用于处理`rejected`状态。这些`回调函数`负责将`源Promise`的状态和值传递给`目标Promise`。

- **创建`PromiseReactionJob`**：当`源Promise`的状态改变时，`V8引擎`会创建第二个`微任务` `PromiseReactionJob`。这个任务负责遍历`源Promise`的`[[PromiseReactions]]`列表，执行所有注册的`反应`，包括`状态吸收逻辑`。

- **状态传递与锁定**：在`PromiseReactionJob`执行过程中，`源Promise`的状态和值会被传递给`目标Promise`。一旦传递完成，`目标Promise`的状态将被`锁定`为与`源Promise`相同的状态，并且这个状态不可逆转。即使`源Promise`后续状态再次改变，也不会影响已经完成`状态吸收`的`目标Promise`。

- **微任务队列清空**：`V8引擎`会持续执行`微任务队列`中的所有任务，直到队列为空。这确保了所有相关的`状态吸收`操作都能在当前`事件循环`的`微任务阶段`完成，保证了`Promise`状态的一致性。

```javascript
// 示例代码展示吸收阶段
const promise1 = Promise.resolve('success');
const promise2 = new Promise((resolve, reject) => {
  resolve(promise1); // 准备阶段
});

// 吸收阶段：
// 1. promise1的fulfilled状态传递给promise2
// 2. 执行promise2的resolve回调，传入promise1的值'success'
// 3. promise2的状态被锁定为fulfilled，值为'success'

promise2.then((value) => {
  console.log(value); // 输出: 'success'
});
```

### 状态吸收的内部机制 {#状态吸收的内部机制}

在`V8引擎`内部，`状态吸收`是通过以下精密的机制实现的：

1. **`PromiseThenableJob`**：当`resolve`一个`Promise`对象时，`V8`会创建一个`PromiseThenableJob`微任务，这个任务负责处理`状态吸收`的核心逻辑。它会调用`源Promise`的`then`方法，并传入两个`回调函数`：一个用于处理`fulfilled`状态，另一个用于处理`rejected`状态。这些`回调函数`会创建`PromiseReaction`对象，并将其添加到`源Promise`的`[[PromiseReactions]]`列表中。

2. **`PromiseReaction`**：每个`Promise`都有一个内部属性`[[PromiseReactions]]`，这是一个列表，存储了所有依赖它的`Promise`的`反应`（reactions）。每个`PromiseReaction`对象包含了`目标Promise`的引用、处理`fulfilled`状态的`回调函数`和处理`rejected`状态的`回调函数`。当`源Promise`状态改变时，`V8引擎`会遍历这个列表，为每个`PromiseReaction`创建一个`PromiseReactionJob`微任务。

3. **`PromiseResolveThenableJob`**：这是一个特殊的`微任务`，专门用于处理`thenable`对象（包括`Promise`）的`状态吸收`。它的工作流程是：
   - 调用`thenable`对象的`then`方法
   - 传入两个`回调函数`，分别处理`fulfilled`和`rejected`状态
   - 这些`回调函数`会确保`目标Promise`的状态与`thenable`对象的状态保持同步
   - 如果`thenable`对象已经是`fulfilled`或`rejected`状态，会立即创建`PromiseReactionJob`微任务

这三个机制协同工作，确保`Promise`状态能够正确地在不同的`Promise`对象之间传递和同步，同时保证了`异步操作`的顺序性和一致性。

```javascript
// 内部实现模拟
function PromiseResolveThenableJob(promiseToResolve, thenable, then) {
  // 创建PromiseReaction对象，包含目标Promise的引用和回调函数
  const reaction = {
    promise: promiseToResolve,
    fulfillCallback: (value) => {
      // 当thenable fulfilled时，promiseToResolve也fulfilled
      PromiseResolve(promiseToResolve, value);
    },
    rejectCallback: (reason) => {
      // 当thenable rejected时，promiseToResolve也rejected
      PromiseReject(promiseToResolve, reason);
    }
  };

  // 将reaction添加到thenable的[[PromiseReactions]]列表中
  if (!thenable[[PromiseReactions]]) {
    thenable[[PromiseReactions]] = [];
  }
  thenable[[PromiseReactions]].push(reaction);

  // 调用thenable的then方法，传入处理fulfilled和rejected的回调函数
  try {
    then.call(
      thenable,
      (value) => {
        // 创建PromiseReactionJob微任务，处理fulfilled状态
        enqueuePromiseReactionJob(reaction, 'fulfill', value);
      },
      (reason) => {
        // 创建PromiseReactionJob微任务，处理rejected状态
        enqueuePromiseReactionJob(reaction, 'reject', reason);
      }
    );
  } catch (error) {
    // 如果调用then方法时抛出异常，直接reject目标Promise
    PromiseReject(promiseToResolve, error);
  }
}

// 执行PromiseReactionJob的函数
function PromiseReactionJob(reaction, type, value) {
  if (type === 'fulfill') {
    // 执行fulfill回调，传递value
    reaction.fulfillCallback(value);
  } else {
    // 执行reject回调，传递reason
    reaction.rejectCallback(value);
  }
}
```

## 实例 {#实例}

```javascript codeRunTask
---
data: {
  config: {

  },
  runSteps: [
    {
      id: 1,
      type: "synchronous",
      task: "声明全局变量 promise1",
      taskName: "promise1",
      createTask: {},
      codeNumbers: [1],
      result: "创建全局变量 **promise1**，调用Promise.resolve('success')，Promise.resolve内部执行，创建已fulfilled的Promise对象，赋值为 _Promise {&lt;fulfilled&gt;: 'success'}_",
      console: "",
      runTime: 2000
    },
    {
      id: 2,
      type: "synchronous",
      task: "声明全局变量 promise2",
      taskName: "promise2",
      createTask: {},
      codeNumbers: [2,3,4],
      result: "创建全局变量 **promise2**，执行Promise构造函数",
      console: "",
      runTime: 2000
    },
    {
      id: 3,
      type: "synchronous",
      task: "promise2 准备吸收 promise1 的状态",
      taskName: "resolve(promise1)",
      createTask: {
        type: "microtask",
        taskId: 6,
      },
      codeNumbers: [3],
      result: '调用 **resolve(promise1)**，resolve检测到参数是Promise，触发Promise状态吸收，返回一个pending状态的Promise对象，赋值为 _Promise { &lt;pending&gt; }_ <br>创建任务 `准备吸收` 到微队列',
      console: "",
      runTime: 2000
    },
    {
      id: 4,
      type: "synchronous",
      task: "注册promise2的then链",
      taskName: "p2注册then回调",
      createTask: {},
      codeNumbers: [6,7,8,9,10,11,12,13,14],
      result: "注册then回调：`p2-then1` `p2-then2` `p2-then3`<br>因为 **promise2** 仍是pending状态，回调不执行，仅注册，继续执行后续同步代码",
      console: "",
      runTime: 2000
    },
    {
      id: 5,
      type: "synchronous",
      task: "注册promise1的then链",
      taskName: "p1注册then回调",
      createTask: {
        type: "microtask",
        taskId: 7,
      },
      codeNumbers: [16,17,18,19,20,21,22,23,24],
      result: "注册then回调：`p1-then1` `p1-then2` `p1-then3`<br>由于 **promise1** 已经是fulfilled状态，第一个then的回调被放入微任务队列，同步代码结束。<br>创建任务 `p1-then1` 到微队列",
      console: "",
      runTime: 2000
    },
    {
      id: 6,
      type: "microtask",
      task: "执行微任务：准备吸收",
      taskName: "准备吸收",
      createTask: {
        type: "microtask",
        taskId: 8,
      },
      codeNumbers: [3],
      result: "**promise2**吸收状态准备阶段完成，创建任务 `吸收状态` 到微队列",
      console: "",
      runTime: 2000
    },
    {
      id: 7,
      type: "microtask",
      task: "执行微任务：p1-then1",
      taskName: "p1-then1",
      createTask: {
        type: "microtask",
        taskId: 9,
      },
      codeNumbers: [17],
      result: "`p1-then1` 回调完成，返回undefined，新创建的Promise变为fulfilled状态，执行 **promise1** 的第二个then `p1-then2`，创建任务 `p1-then2` 到微队列<br>输出结果：4",
      console: "4",
      runTime: 2000
    },
    {
      id: 8,
      type: "microtask",
      task: "执行微任务：吸收状态",
      taskName: "吸收状态",
      createTask: {
        type: "microtask",
        taskId: 10,
      },
      codeNumbers: [3],
      result: "**promise2**吸收状态完成，执行 `p2-then1` 回调，创建任务 `p2-then1` 到微队列",
      console: "",
      runTime: 2000
    },
    {
      id: 9,
      type: "microtask",
      task: "执行微任务：p1-then2",
      taskName: "p1-then2",
      createTask: {
        type: "microtask",
        taskId: 11,
      },
      codeNumbers: [20],
      result: "`p1-then2` 回调完成，返回undefined，新创建的Promise变为fulfilled状态，执行 **promise1** 的第三个then `p1-then3`，创建任务 `p1-then3` 到微队列<br>输出结果：5",
      console: "5",
      runTime: 2000
    },
    {
      id: 10,
      type: "microtask",
      task: "执行微任务：p2-then1",
      taskName: "p2-then1",
      createTask: {
        type: "microtask",
        taskId: 12,
      },
      codeNumbers: [7],
      result: "`p2-then1` 回调完成，返回undefined，新创建的Promise变为fulfilled状态，执行 **promise2** 的第二个then `p2-then2`，创建任务 `p2-then2` 到微队列<br>输出结果：1",
      console: "1",
      runTime: 2000
    },
    {
      id: 11,
      type: "microtask",
      task: "执行微任务：p1-then3",
      taskName: "p1-then3",
      createTask: {},
      codeNumbers: [23],
      result: "`p1-then3` 回调完成，**promise1**调用已完成，执行后续任务<br>输出结果：6",
      console: "6",
      runTime: 2000
    },
    {
      id: 12,
      type: "microtask",
      task: "执行微任务：p2-then2",
      taskName: "p2-then2",
      createTask: {
        type: "microtask",
        taskId: 13,
      },
      codeNumbers: [10],
      result: "`p2-then2` 回调完成，返回undefined，新创建的Promise变为fulfilled状态，执行 **promise2** 的第三个then `p2-then3`，创建任务 `p2-then3` 到微队列<br>输出结果：2",
      console: "2",
      runTime: 2000
    },
    {
      id: 13,
      type: "microtask",
      task: "执行微任务：p2-then3",
      taskName: "p2-then3",
      createTask: {},
      codeNumbers: [13],
      result: "`p2-then3` 回调完成，**promise2**调用已完成，微队列已清空，程序执行完毕<br>输出结果：3",
      console: "3",
      runTime: 2000
    }
  ]
}
---
const promise1 = Promise.resolve('success');
const promise2 = new Promise((resolve, reject) => {
  resolve(promise1);
});

promise2.then(() => {
    console.log(1);
  })
  .then(() => {
    console.log(2);
  })
  .then(() => {
    console.log(3);
  });

promise1.then(() => {
    console.log(4);
  })
  .then(() => {
    console.log(5);
  })
  .then(() => {
    console.log(6);
  });
```

## 注意事项 {#注意事项}

1. **循环依赖**：如果两个`Promise`互相吸收对方的状态，会导致无限循环，`V8引擎`会检测这种情况并抛出错误。

```javascript
const promise1 = new Promise((resolve) => {
  // 循环依赖，会抛出错误
  resolve(promise2);
});

const promise2 = new Promise((resolve) => {
  // 循环依赖，会抛出错误
  resolve(promise1);
});
```

2. **性能考虑**：`状态吸收`涉及`微任务`的创建和执行，过多的`Promise`链式调用可能会影响性能。

3. **调试困难**：由于`状态吸收`是异步的，且涉及内部机制，在调试时可能会增加复杂度。

通过`状态吸收`机制，`Promise`能够实现复杂的状态传递和依赖关系管理，这是`Promise`链式调用和异步编程的重要基础。
